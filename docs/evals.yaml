# CodifierMcp Evaluations
# Tracking validation of rules against actual implementation

evaluations:
  - id: "E001"
    rule_id: "R001"
    status: "passing"
    test_case: "Configuration validation with Zod"
    result: "Zod schemas properly validate all environment variables with descriptive error messages. No placeholders or TODOs in config module."
    evidence:
      - "src/config/env.ts uses Zod schema validation"
      - "All fields have .describe() documentation"
      - "ConfigurationError thrown with actionable messages"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"

  - id: "E002"
    rule_id: "R002"
    status: "passing"
    test_case: "Logger implementation simplicity"
    result: "Logger uses direct console.error calls without unnecessary framework complexity. Single-purpose Logger class with clear responsibility."
    evidence:
      - "src/utils/logger.ts implements lean Logger class"
      - "No external logging dependencies"
      - "Simple log level filtering logic"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"

  - id: "E003"
    rule_id: "R003"
    status: "passing"
    test_case: "MCP protocol compliance - stderr logging"
    result: "All logging uses console.error (stderr) to avoid polluting stdout which is reserved for MCP protocol communication."
    evidence:
      - "Logger class uses console.error for all log levels"
      - "No console.log usage in codebase"
      - "MCP protocol communication isolated to stdout"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"

  - id: "E004"
    rule_id: "R004"
    status: "passing"
    test_case: "ESM module system consistency"
    result: "All imports use .js extensions and ESM syntax. package.json has 'type: module'. TypeScript configured for ESNext modules."
    evidence:
      - "package.json has type: module"
      - "tsconfig.json uses module: ESNext"
      - "All imports include .js extension"
      - "No require() usage in codebase"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"

  - id: "E005"
    rule_id: "R005"
    status: "passing"
    test_case: "IDataStore abstraction layer"
    result: "Clean interface definition allows easy migration from AtlassianDataStore to future SupabaseDataStore. No Confluence-specific details in interface."
    evidence:
      - "src/datastore/interface.ts defines generic IDataStore"
      - "Methods use generic types (Rule[], Insight[])"
      - "No Confluence-specific types in interface signatures"
      - "AtlassianDataStore implements IDataStore cleanly"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"

  - id: "E006"
    rule_id: "R006"
    status: "passing"
    test_case: "Error hierarchy and handling"
    result: "Custom error classes with clear hierarchy. Errors include context (cause, toolName, etc.). Logging before throwing."
    evidence:
      - "src/utils/errors.ts defines error hierarchy"
      - "CodifierError -> DataStoreError -> ConfluenceError"
      - "All error classes include contextual properties"
      - "Error.captureStackTrace used for clean stacks"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"

  - id: "E007"
    rule_id: "R007"
    status: "passing"
    test_case: "Configuration management with defaults"
    result: "All configuration uses Zod validation with sensible defaults and descriptions. Singleton pattern with caching."
    evidence:
      - "envSchema in src/config/env.ts"
      - "Defaults for RULES_PAGE_TITLE, INSIGHTS_PARENT_PAGE_TITLE, LOG_LEVEL"
      - "All fields documented with .describe()"
      - "getConfig() provides cached singleton"
      - "resetConfig() available for testing"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"

  - id: "E008"
    rule_id: "R008"
    status: "passing"
    test_case: "TypeScript strict mode configuration"
    result: "Strict mode enabled in tsconfig.json. All exported functions have explicit return types. No implicit any."
    evidence:
      - "tsconfig.json has strict: true"
      - "All exported functions have return type annotations"
      - "Interface definitions for all complex types"
      - "No usage of explicit 'any' without justification"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"

  - id: "E009"
    rule_id: "R009"
    status: "passing"
    test_case: "Module organization by domain"
    result: "Clear separation of concerns: config/, datastore/, utils/ directories. Interfaces separate from implementations."
    evidence:
      - "src/config/ for configuration"
      - "src/datastore/ for data access layer"
      - "src/utils/ for cross-cutting concerns"
      - "interface.ts separate from atlassian-datastore.ts"
      - "No circular dependencies detected"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"

  - id: "E010"
    rule_id: "R010"
    status: "passing"
    test_case: "Testable configuration design"
    result: "Configuration module provides resetConfig() for test cleanup. Dependency injection pattern used for IDataStore."
    evidence:
      - "resetConfig() exported for testing"
      - "IDataStore interface enables mocking"
      - "Pure validation logic separate from I/O"
      - "Singleton with reset capability"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"

  - id: "E011"
    rule_id: "R011"
    status: "passing"
    test_case: "JSDoc documentation on interfaces and types"
    result: "All interfaces, exported functions, and types have JSDoc comments. Documentation explains purpose and error conditions."
    evidence:
      - "IDataStore interface fully documented"
      - "All public functions have JSDoc with @param, @returns, @throws"
      - "Type definitions include descriptions"
      - "Error classes documented with use cases"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"

  - id: "E012"
    rule_id: "R003"
    status: "needs-validation"
    test_case: "MCP tool schema validation with Zod"
    result: "Tool schemas should use Zod for runtime validation (not yet implemented in Phase 1)"
    evidence:
      - "MCP server implementation pending"
      - "Tool schemas will be defined in Phase 2"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"
    notes: "Will be validated once MCP server tools are implemented"

  - id: "E013"
    rule_id: "R005"
    status: "needs-validation"
    test_case: "Supabase migration path"
    result: "IDataStore interface designed for migration, but Supabase implementation not yet created"
    evidence:
      - "Interface allows for SupabaseDataStore implementation"
      - "No Confluence-specific coupling in interface"
    date: "2025-01-13"
    reviewer: "Phase 1 Implementation Review"
    notes: "Will be validated in Phase 2 when SupabaseDataStore is implemented"

  - id: "E014"
    rule_id: "R013"
    status: "passing"
    test_case: "Stateless StreamableHTTP transport on POST /mcp"
    result: "Each POST /mcp creates a fresh Server + StreamableHTTPServerTransport with sessionIdGenerator: undefined. No session registry. No restart-induced hangs."
    evidence:
      - "src/http/server.ts uses sessionIdGenerator: undefined on StreamableHTTPServerTransport"
      - "Per-request mcpServer created via config.createServer() factory"
      - "res.on('close') cleanup handler registered for transport and server"
      - "GET /mcp and DELETE /mcp return 405 (no sessions to manage)"
      - "src/index.ts passes createServer factory; dataStore initialized once at startup"
      - "Root cause: Fly.io restart cleared in-memory registry; old session IDs returned 400 → client hung"
    date: "2026-02-28"
    reviewer: "Stateless Transport Fix"

  - id: "E015"
    rule_id: "R014"
    status: "passing"
    test_case: "No module-level session registry in StreamableHTTP path"
    result: "The POST /mcp handler creates fresh state per request. No module-level Map, object, or variable accumulates cross-request state in the StreamableHTTP code path."
    evidence:
      - "src/http/server.ts: no module-scope session Map for /mcp"
      - "config.createServer() factory called fresh on every POST /mcp"
      - "Root cause of the production bug (2026-02-28): `const transports: Record<string, ...>` was module-level, wiped on Fly.io restart"
      - "Fix: removed registry entirely; transport created and discarded per request"
      - "SSE registry (sseTransports) is intentionally kept but is connection-scoped and acceptable for that transport"
    date: "2026-02-28"
    reviewer: "Stateless Transport Fix"

  - id: "E016"
    rule_id: "R015"
    status: "passing"
    test_case: "POST /mcp is self-contained; no cross-request context required"
    result: "All five MCP tools (fetch_context, update_memory, manage_projects, pack_repo, query_data) receive full input in the POST body and return a complete response. No tool accumulates state that must persist to a subsequent request."
    evidence:
      - "src/mcp/tools/*.ts: all handlers receive args from request payload only"
      - "dataStore is initialized once at startup (process lifetime), not per request — correct, since Supabase client is stateless"
      - "transport.close() and mcpServer.close() called on res.on('close') — no leakage between requests"
      - "tests/http-server.test.js covers stateless POST, missing session header, and stale session header scenarios"
    date: "2026-02-28"
    reviewer: "Stateless Transport Fix"

  - id: "E017"
    rule_id: "R016"
    status: "passing"
    test_case: "All durable writes go through SupabaseDataStore, not local disk"
    result: "Inspection of all tool handlers and the datastore implementation confirms no fs.writeFile/fs.appendFile calls outside of temporary repomix scratch usage."
    evidence:
      - "src/datastore/supabase-datastore.ts: all persistence via @supabase/supabase-js client"
      - "src/integrations/repomix.ts: repomix pack() runs in memory; snapshot string passed to saveRepository() → Supabase"
      - "No direct fs.writeFileSync or fs.appendFileSync in src/mcp/tools/"
      - "Environment config read from process.env via Zod (src/config/env.ts); never written to disk"
    date: "2026-02-28"
    reviewer: "Stateless Transport Fix"

summary:
  total_evaluations: 17
  passing: 15
  failing: 0
  needs_validation: 2
  coverage: "All Phase 1 rules validated; stateless transport fix and PaaS resilience rules added (2026-02-28)"
  next_steps:
    - "Validate MCP tool schema patterns when server is implemented"
    - "Validate Supabase migration when Phase 2 begins"
    - "Run tests/http-server.test.js as part of CI to keep E015/E016 continuously validated"
    - "Track rule evolution as new patterns emerge"