# CodifierMcp Development Rules
# Best practices and patterns captured from Phase 1 implementation

rules:
  - id: "R001"
    category: "code-quality"
    title: "Production-Ready Code Only"
    description: "All code should be production-ready with no placeholders, TODOs, or stub implementations. Every function must be fully implemented with proper error handling, validation, and logging."
    confidence: 1.0
    patterns:
      - "Implement complete error handling with custom error classes"
      - "Use proper TypeScript types, avoid 'any' unless absolutely necessary"
      - "Include descriptive logging at appropriate levels (debug, info, warn, error)"
      - "Validate inputs using Zod schemas or TypeScript guards"
      - "Handle edge cases and failure scenarios explicitly"
    antipatterns:
      - "Using placeholder functions like 'TODO: implement this'"
      - "Leaving console.log statements without proper logging framework"
      - "Using 'any' type without clear justification in comments"
      - "Empty catch blocks that silently swallow errors"
      - "Unvalidated user inputs or configuration values"
    examples:
      - "Good: Custom error classes with clear hierarchy (CodifierError -> DataStoreError -> ConfluenceError)"
      - "Bad: try/catch with empty or generic catch block"
      - "Good: Zod schema validation with clear error messages"
      - "Bad: Direct use of process.env without validation"
    metadata:
      created: "2025-01-13"
      priority: "high"
      tags: ["code-quality", "production-readiness", "error-handling"]

  - id: "R002"
    category: "code-quality"
    title: "Lean and Concise Implementations"
    description: "Keep code lean and focused. Avoid over-engineering or adding unnecessary abstractions. Write code that solves the immediate problem without premature optimization or feature creep."
    confidence: 1.0
    patterns:
      - "Write single-purpose functions with clear responsibilities"
      - "Avoid premature optimization - optimize when profiling shows need"
      - "Use built-in language features over external libraries when simple"
      - "Keep class hierarchies shallow and focused"
      - "Implement only features that are in the requirements"
    antipatterns:
      - "Creating complex inheritance hierarchies for simple tasks"
      - "Adding features that aren't in requirements 'just in case'"
      - "Over-abstracting with unnecessary interfaces or generics"
      - "Premature caching or performance optimization"
      - "Adding dependencies for simple tasks that could be done natively"
    examples:
      - "Good: Logger class with direct console.error calls, no complex framework"
      - "Bad: Multiple abstraction layers for simple logging"
      - "Good: IDataStore interface with only required methods"
      - "Bad: Generic repository pattern with CRUD operations we don't need"
    metadata:
      created: "2025-01-13"
      priority: "high"
      tags: ["code-quality", "simplicity", "yagni"]

  - id: "R003"
    category: "mcp-protocol"
    title: "MCP Protocol Best Practices"
    description: "Follow MCP protocol conventions strictly. Use stderr for all logging since stdout is reserved for MCP protocol communication. Define clear tool schemas with proper validation. The server exposes exactly 5 tools: fetch_context, update_memory, manage_projects, pack_repo, query_data."
    confidence: 1.0
    patterns:
      - "Use console.error (stderr) for all logging, never console.log (stdout)"
      - "Define tool schemas using Zod for runtime validation"
      - "Provide clear, actionable error messages in tool responses"
      - "Use proper MCP SDK types (Server, StdioServerTransport, CallToolRequestSchema)"
      - "Handle MCP lifecycle events (initialize, cleanup)"
    antipatterns:
      - "Using console.log which pollutes stdout and breaks MCP protocol"
      - "Returning unstructured error messages from MCP tools"
      - "Missing input validation in tool handlers"
      - "Not handling MCP transport errors gracefully"
      - "Exposing internal error details to MCP clients"
      - "Adding tools beyond the 5 defined in the v2.0 surface (fetch_context, update_memory, manage_projects, pack_repo, query_data)"
    examples:
      - "Good: logger.error() uses console.error for MCP compatibility"
      - "Bad: console.log('Debug info') breaks MCP communication"
      - "Good: Zod schema validation before processing tool requests"
      - "Bad: Assuming tool inputs are valid without validation"
    metadata:
      created: "2025-01-13"
      priority: "critical"
      tags: ["mcp", "protocol", "logging", "validation"]

  - id: "R004"
    category: "module-system"
    title: "ESM Module System Consistency"
    description: "Use ECMAScript Modules (ESM) consistently throughout the project. Include .js extensions in all import statements, even when importing TypeScript files."
    confidence: 1.0
    patterns:
      - "Use 'type: module' in package.json"
      - "Use import/export syntax, never require/module.exports"
      - "Include .js extensions in all relative imports (import { x } from './file.js')"
      - "Use ESNext module system in tsconfig.json"
      - "Use top-level await when needed (available in ESM)"
    antipatterns:
      - "Mixing CommonJS require() with ESM import"
      - "Omitting .js extensions from imports"
      - "Using __dirname or __filename without ESM alternatives"
      - "Setting 'type: commonjs' or omitting type field"
      - "Using .ts extensions in imports"
    examples:
      - "Good: import { logger } from './utils/logger.js'"
      - "Bad: import { logger } from './utils/logger' (missing .js)"
      - "Good: import { logger } from './utils/logger.js'"
      - "Bad: const logger = require('./utils/logger')"
    metadata:
      created: "2025-01-13"
      priority: "high"
      tags: ["esm", "modules", "typescript", "imports"]

  - id: "R005"
    category: "architecture"
    title: "Clean Abstraction for Future Migration"
    description: "Use interface-based abstractions to enable easy migration between storage backends. Keep implementation details in concrete classes, not interfaces."
    confidence: 1.0
    patterns:
      - "Define clear interface contracts (IDataStore)"
      - "Keep interface methods focused on business operations"
      - "Document migration paths in interface comments"
      - "Use dependency injection for swappable implementations"
      - "Hide implementation-specific details behind the interface"
    antipatterns:
      - "Leaking implementation details into interface definitions"
      - "Creating interfaces that are tightly coupled to one implementation"
      - "Direct instantiation instead of dependency injection"
      - "Implementation-specific types in interface signatures"
      - "Bypassing the interface to access implementation details"
    examples:
      - "Good: IDataStore interface allows AtlassianDataStore or SupabaseDataStore"
      - "Bad: Interface with Confluence-specific method signatures"
      - "Good: fetchMemories() returns generic Memory[] type"
      - "Bad: saveMemory() accepts a SupabaseRow type instead of the domain Memory type"
    metadata:
      created: "2025-01-13"
      priority: "high"
      tags: ["architecture", "abstraction", "migration", "interfaces"]

  - id: "R006"
    category: "error-handling"
    title: "Comprehensive Error Handling Standards"
    description: "Use custom error classes with clear hierarchy. Log errors before throwing for debugging. Provide actionable error messages that help users fix issues."
    confidence: 1.0
    patterns:
      - "Create error hierarchy (CodifierError as base class)"
      - "Include error context (cause, toolName, content, etc.)"
      - "Log errors before throwing for debugging trail"
      - "Provide actionable error messages with guidance"
      - "Use Error.captureStackTrace for clean stack traces"
    antipatterns:
      - "Throwing generic Error instances"
      - "Error messages without context or guidance"
      - "Catching errors without logging"
      - "Swallowing errors silently in catch blocks"
      - "Exposing internal error details to end users"
    examples:
      - "Good: throw new ConfluenceError('Failed to fetch page', originalError)"
      - "Bad: throw new Error('Error occurred')"
      - "Good: logger.error before throw for debugging context"
      - "Bad: throw error without any logging"
    metadata:
      created: "2025-01-13"
      priority: "high"
      tags: ["error-handling", "logging", "debugging"]

  - id: "R007"
    category: "configuration"
    title: "Robust Configuration Management"
    description: "Use Zod for runtime validation of all configuration. Provide sensible defaults where appropriate. Document all environment variables with descriptions."
    confidence: 1.0
    patterns:
      - "Define Zod schemas for all configuration"
      - "Use .default() for optional config with sensible defaults"
      - "Add .describe() to document each config field"
      - "Validate early at application startup"
      - "Cache validated config in singleton pattern"
      - "Throw ConfigurationError with clear validation messages"
    antipatterns:
      - "Direct access to process.env without validation"
      - "Undefined or missing defaults for optional config"
      - "Configuration validation spread throughout codebase"
      - "Unclear error messages for validation failures"
      - "Re-parsing environment on every access"
    examples:
      - "Good: z.string().default('info').describe('Logging level')"
      - "Bad: const level = process.env.LOG_LEVEL || 'info'"
      - "Good: Centralized loadConfig() with Zod validation"
      - "Bad: Scattered process.env checks throughout code"
    metadata:
      created: "2025-01-13"
      priority: "high"
      tags: ["configuration", "validation", "zod", "environment"]

  - id: "R008"
    category: "typescript"
    title: "Strict TypeScript Configuration"
    description: "Enable strict mode and proper compiler options. Use explicit types for function parameters and return values. Avoid implicit any."
    confidence: 1.0
    patterns:
      - "Enable 'strict: true' in tsconfig.json"
      - "Use explicit return types on all exported functions"
      - "Define interfaces for complex object shapes"
      - "Use type guards for runtime type checking"
      - "Leverage TypeScript utility types (Record, Partial, Pick, etc.)"
    antipatterns:
      - "Implicit any from missing type annotations"
      - "Using 'any' without justification"
      - "Disabling strict mode or specific strict checks"
      - "Missing return type annotations"
      - "Using type assertions (as) to bypass type checking"
    examples:
      - "Good: export function loadConfig(): EnvConfig { ... }"
      - "Bad: export function loadConfig() { ... } (no return type)"
      - "Good: interface Rule with all properties typed"
      - "Bad: const rule: any = { ... }"
    metadata:
      created: "2025-01-13"
      priority: "high"
      tags: ["typescript", "types", "strict-mode"]

  - id: "R009"
    category: "code-organization"
    title: "Clear Module Organization"
    description: "Organize code into logical modules with clear responsibilities. Keep related functionality together. Use barrel exports (index.ts) sparingly."
    confidence: 1.0
    patterns:
      - "Group by feature/domain (config/, datastore/, utils/)"
      - "Keep interfaces separate from implementations"
      - "Use clear, descriptive file names"
      - "One primary export per file (with exceptions for types)"
      - "Avoid circular dependencies"
    antipatterns:
      - "Mixing unrelated functionality in one file"
      - "Deeply nested directory structures"
      - "Barrel exports that obscure dependencies"
      - "Circular dependencies between modules"
      - "God files with multiple unrelated exports"
    examples:
      - "Good: datastore/interface.ts and datastore/atlassian-datastore.ts"
      - "Bad: datastore/index.ts with interface and all implementations"
      - "Good: utils/logger.ts and utils/errors.ts as separate files"
      - "Bad: utils.ts with logger, errors, and validators mixed"
    metadata:
      created: "2025-01-13"
      priority: "medium"
      tags: ["code-organization", "modules", "structure"]

  - id: "R010"
    category: "testing"
    title: "Test-Friendly Design Patterns"
    description: "Design code to be testable from the start. Use dependency injection, avoid singletons that can't be reset, and separate pure logic from side effects."
    confidence: 0.9
    patterns:
      - "Use dependency injection for external dependencies"
      - "Provide factory functions or constructors (avoid hard-coded singletons)"
      - "Separate pure functions from side-effect functions"
      - "Export helper functions for testing"
      - "Design interfaces that can be mocked easily"
    antipatterns:
      - "Hard-coded singleton instances that can't be reset"
      - "Direct import of singletons instead of dependency injection"
      - "Mixing business logic with I/O operations"
      - "Private methods that need testing but aren't testable"
      - "Global state that persists across tests"
    examples:
      - "Good: export function resetConfig() for test cleanup"
      - "Bad: Singleton with no way to reset state"
      - "Good: IDataStore interface that can be mocked"
      - "Bad: Direct Confluence API calls in business logic"
    metadata:
      created: "2025-01-13"
      priority: "medium"
      tags: ["testing", "testability", "design", "dependency-injection"]

  - id: "R011"
    category: "documentation"
    title: "Inline Documentation Standards"
    description: "Use JSDoc comments for all exported functions, interfaces, and types. Focus on why and context, not what (code should be self-explanatory for what)."
    confidence: 1.0
    patterns:
      - "JSDoc comments for all public APIs"
      - "Document parameters, return types, and thrown errors"
      - "Explain the 'why' and 'when to use', not just 'what'"
      - "Include examples in documentation for complex APIs"
      - "Use @throws tags to document error conditions"
    antipatterns:
      - "Missing documentation on public APIs"
      - "Documentation that just repeats the function name"
      - "Outdated documentation that doesn't match implementation"
      - "Over-documenting obvious implementation details"
      - "Missing error condition documentation"
    examples:
      - "Good: /** Load and validate environment configuration. @throws {ConfigurationError} If validation fails */"
      - "Bad: /** Loads config */ (too minimal)"
      - "Good: Comments explain 'why' in complex logic"
      - "Bad: Comments explain obvious code line-by-line"
    metadata:
      created: "2025-01-13"
      priority: "medium"
      tags: ["documentation", "jsdoc", "comments"]

  - id: "R012"
    category: "architecture"
    title: "Agent Skills Are Client-Side Only"
    description: "Skills are markdown instruction files executed by the client's LLM. The server must not implement workflow state, step sequencing, or session tracking. The LLM reads the SKILL.md and calls MCP tools only for data operations."
    confidence: 1.0
    patterns:
      - "Skills live in skills/<name>/SKILL.md"
      - "Prompt templates live in skills/<name>/templates/"
      - "Skills reference shared/codifier-tools.md for tool usage"
      - "Server tools are stateless data operations only"
    antipatterns:
      - "Server-side session state for workflow tracking"
      - "Tool handlers that advance workflow steps"
      - "TypeScript code that encodes workflow sequences"
      - "LLM calls from within MCP tool handlers"
    examples:
      - "Good: SKILL.md instructs LLM to call update_memory after generating an artifact"
      - "Bad: advance_step tool that tracks which step a user is on"
    metadata:
      created: "2026-02-24"
      priority: "critical"
      tags: ["architecture", "skills", "stateless", "client-side"]

  - id: "R013"
    category: "architecture"
    title: "Stateless StreamableHTTP Transport"
    description: "The /mcp endpoint uses stateless transport mode (sessionIdGenerator: undefined). A new Server and StreamableHTTPServerTransport instance are created per POST request. No in-memory session registry for StreamableHTTP. This prevents hangs after Fly.io restarts, where the registry was cleared but clients still sent old session IDs."
    confidence: 1.0
    patterns:
      - "Pass sessionIdGenerator: undefined to StreamableHTTPServerTransport"
      - "Create new Server + transport per POST /mcp via config.createServer() factory"
      - "Register res.on('close', ...) to clean up transport and server"
      - "Accept createServer: () => Server factory in HttpServerConfig"
      - "SSE transport (/sse) may still use a session registry (it is connection-scoped)"
    antipatterns:
      - "In-memory session registry for StreamableHTTP (lost on Fly.io restart)"
      - "Single long-lived MCP Server shared across HTTP requests"
      - "Requiring Mcp-Session-Id header on /mcp requests"
      - "GET /mcp or DELETE /mcp handlers (no sessions to open/close in stateless mode)"
    examples:
      - "Good: new StreamableHTTPServerTransport({ sessionIdGenerator: undefined })"
      - "Bad: transports[sessionId] = transport (in-memory registry lost on restart)"
    metadata:
      created: "2026-02-28"
      priority: "critical"
      tags: ["architecture", "http", "stateless", "fly.io", "mcp", "transport"]

  - id: "R014"
    category: "architecture"
    title: "No In-Memory State on PaaS — Restarts Wipe It"
    description: "PaaS platforms (Fly.io, Heroku, Railway, etc.) restart machines under normal operation: deploys, health-check failures, scale-to-zero wake-ups, and rolling updates all cause a fresh process. Any in-memory structure — Maps, plain objects, module-level variables — is silently cleared on restart. State that must survive a restart must be stored in an external, persistent service (Supabase, Redis, etc.)."
    confidence: 1.0
    patterns:
      - "Store durable state in Supabase (or another external store), never in process memory"
      - "Treat every request as if the server just cold-started"
      - "Use stateless patterns: derive context from the request payload, not from remembered prior requests"
      - "If you genuinely need per-process ephemeral state, document the restart-loss consequence explicitly"
    antipatterns:
      - "Module-level Maps or objects used as session/state registries (const sessions: Map<string, ...> = new Map())"
      - "Caching request-correlated data in a module-scope variable that lives across requests"
      - "Assuming a long-lived object created at startup will still be reachable on the next request"
      - "Storing user or session identifiers in process memory without an external fallback"
    examples:
      - "Good: Session data written to Supabase row on creation; read from Supabase on each request"
      - "Bad: const sessionRegistry: Record<string, Transport> = {} — cleared on every Fly.io restart"
      - "Good: Stateless request handling; all context reconstructed from the incoming payload"
      - "Bad: if (!sessions[id]) return 400 — silently fails after restart because sessions is empty"
    metadata:
      created: "2026-02-28"
      priority: "critical"
      tags: ["architecture", "paas", "fly.io", "stateless", "restart-resilience", "in-memory"]

  - id: "R015"
    category: "architecture"
    title: "Request-Response MCP Tools Must Be Stateless HTTP"
    description: "MCP tools in CodifierMcp are synchronous request-response operations (fetch, upsert, query). They do not require a persistent connection or multi-turn session. Using stateful HTTP transport for these tools adds restart sensitivity with no benefit. Use stateless POST-per-request transport (StreamableHTTP with sessionIdGenerator: undefined)."
    confidence: 1.0
    patterns:
      - "POST /mcp is the sole entry point; each call is self-contained"
      - "All tool inputs arrive in the POST body; no cross-request context is needed"
      - "Transport and Server instances are created per request and discarded after res close"
      - "Reserve stateful transports (SSE, WebSocket) only for streaming or subscription use cases"
    antipatterns:
      - "Treating request-response tools as if they need a persistent session"
      - "Sharing a single MCP Server instance across concurrent HTTP requests"
      - "Using SSE or WebSocket for tools that return a single synchronous result"
      - "Generating a session ID (sessionIdGenerator: () => uuid()) for tools that do not need it"
    examples:
      - "Good: POST /mcp → new Server() + new StreamableHTTPServerTransport({ sessionIdGenerator: undefined }) → handle → close"
      - "Bad: POST /mcp → sessions[id].transport.handle(req) — stateful, lost on restart"
    metadata:
      created: "2026-02-28"
      priority: "high"
      tags: ["architecture", "http", "mcp", "stateless", "transport", "request-response"]

  - id: "R016"
    category: "architecture"
    title: "Persist Only to Supabase; Never to Local Disk or In-Process"
    description: "On Fly.io, the local filesystem is ephemeral and not shared between machines. All durable writes — memories, project records, repository snapshots — must go to Supabase. Never write to local files as a caching or persistence strategy. Configuration may be read from environment variables (provided by Fly.io secrets), but must not be written back to disk."
    confidence: 1.0
    patterns:
      - "Write all durable data through IDataStore (SupabaseDataStore)"
      - "Read configuration from environment variables; never write it back to disk"
      - "Treat the local filesystem as read-only scratch (e.g., temporary files during repomix packing)"
      - "Clean up any temporary files written to disk within the same request lifecycle"
    antipatterns:
      - "Writing JSON or YAML state files to the local filesystem as a cache"
      - "Persisting user data to /tmp expecting it to survive across requests or restarts"
      - "Module-level file-system writes that accumulate state over the process lifetime"
      - "Forking a subprocess that writes to disk and assuming the file persists"
    examples:
      - "Good: upsertMemory() → Supabase INSERT/UPSERT"
      - "Bad: fs.writeFileSync('./cache.json', JSON.stringify(data)) — lost on restart"
      - "Good: repomix snapshot written to Supabase repositories table immediately after packing"
      - "Bad: Saving repomix output to /tmp/repo-snapshot.txt and reading it later"
    metadata:
      created: "2026-02-28"
      priority: "high"
      tags: ["architecture", "paas", "fly.io", "persistence", "supabase", "filesystem"]